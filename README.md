# ðŸ§  **Level: 1/10 - Ethereum / Solidity Projects (Beginner)**

## Basic Smart Contract Fundamentals (1-15)
1. Hello World Smart Contract
2. Smart Contract to Store a Number
3. Basic Counter (Increment / Decrement)
4. Store and Retrieve a String
5. Store an Array of Numbers
6. Add Two Numbers Using a Smart Contract
7. Return Sum of an Array
8. Check if a Number is Even or Odd
9. Contract with Multiple Public Variables
10. Basic Struct with Person Info
11. Array of Structs (e.g. Users)
12. Simple Mapping of ID to Names
13. Store and Retrieve a Boolean
14. Add Two Structs Together
15. Read from a Constant Variable

## Contract Logic and Control Flow (16-30)
16. Implement a Simple If-Else Logic
17. Create a Modifier for Access Control
18. Contract with Fallback Function
19. Receive Ether in a Smart Contract
20. Withdraw Ether from a Contract
21. Payable Function Example
22. Deploy a Contract with Initial Value
23. Pass a Struct to Constructor
24. Return Struct Data from a Function
25. Emit a Basic Event
26. Listen for an Event in Frontend
27. Create a Smart Contract Wallet
28. Simple Voting Contract (no validations)
29. Mapping with Address to Balance
30. Store User Info by Address

## Smart Contract Security and Access Control (31-45)
31. Return Caller's Address (msg.sender)
32. Basic Time Lock Using block.timestamp
33. Restrict Function Call to Owner
34. Only Allow Whitelisted Addresses
35. Create and Access an Enum
36. Create a Contract that Self-destructs
37. Gas Estimation Experiment Contract
38. Interact with Your Contract Using Remix
39. Import OpenZeppelin and Use Ownable
40. Send Ether to Another Address
41. Log a Transaction Hash
42. Basic Frontend with Ethers.js and MetaMask
43. Simple Authentication Using msg.sender
44. Simulate a Bank Deposit System
45. Implement an Address Array

## Data Storage and Retrieval (46-60)
46. Save Data to a Mapping and Fetch It
47. Create and Use an Interface
48. Set and Get User Profiles
49. Get Block Number in a Function
50. Store and Return an Ethereum Address
51. Use Keccak256 Hash in Solidity
52. String Comparison in Solidity
53. Implement a Ternary Operation
54. Basic Smart Contract Deployment Script using Hardhat
55. Use Constructor to Initialize Variables
56. Add Custom Errors and Reverts
57. Smart Contract with Math Operations
58. Chain Two Functions Together
59. Return Multiple Values From a Function
60. Store a Dynamic Array

## Smart Contract Development and Best Practices (61-75)
61. Create Contract Using Inheritance
62. Basic DAO Voting System (No Token)
63. Store and Retrieve Contract Deployment Time
64. Compare Gas Cost for Struct vs Mapping
65. Implement Simple Access Logs
66. Generate and Store User ID (counter-based)
67. Create and Track Unique Users
68. Implement a Simple Calculator (Add, Sub, etc.)
69. Contract that Sends Ether to msg.sender
70. Simple Contract Pause/Unpause Functionality
71. Assign Roles Manually (No Role Management System)
72. Create Simple Wallet Contract with Balance
73. Return msg.value from Payable Function
74. Store IPFS Hashes in Smart Contract
75. Add a Struct with Address and Balance

## Practical Smart Contract Applications (76-100)
76. Mapping of Usernames to Addresses
77. Multi-variable Comparison in If Statements
78. Create a Smart Contract-based Todo List
79. Create and Use a Custom Data Type
80. Add/Remove Items from an Array
81. Get Total Count of Users Registered
82. Use Loop to Sum Values in Array
83. Add a Unique Key Check Before Insert
84. Validate Simple Login using Address Mapping
85. Create Dummy Data on Contract Deployment
86. Emit Event When Data is Changed
87. Use require/assert for Simple Checks
88. Implement a Split Payment System
89. Use block.number in Your Logic
90. Return Address Type from a Function
91. Use Interface to Call Another Contract
92. Create a Mock Contract for Testing
93. Deploy Contract and Interact with It on Goerli
94. Estimate Gas Cost of Your Function
95. Create & Query Simple On-chain Log
96. Retrieve Contract's Ether Balance
97. Create a Contract Factory Pattern
98. Basic Signature Verification Logic
99. Implement a Simple Loop Counter
100. Minimal NFT Skeleton with Hardcoded Metadata (no OpenZeppelin)

These beginner-level projects are ideal for learning the basics of Ethereum smart contract development using Solidity. They introduce fundamental concepts like data types, access control, events, mappings, and gas optimization â€” all essential for your journey into blockchain development.